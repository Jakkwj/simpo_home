"use strict";(self.webpackChunksimpo_home=self.webpackChunksimpo_home||[]).push([[7680],{7748:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var t=i(4848),l=i(8453);const o={sidebar_position:11},a=void 0,s={id:"SIMPO/2024",title:"2024",description:"2024-04-30",source:"@site/i18n/zh/docusaurus-plugin-content-docs-changelog/current/SIMPO/2024.md",sourceDirName:"SIMPO",slug:"/SIMPO/2024",permalink:"/zh/changelog/SIMPO/2024",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11},sidebar:"docs",previous:{title:"2024",permalink:"/zh/changelog/SIMPO Backend/2024"},next:{title:"2023",permalink:"/zh/changelog/SIMPO/Earlier/2023"}},r={},c=[{value:"2024-04-30",id:"2024-04-30",level:2},{value:"2024-04-28",id:"2024-04-28",level:2},{value:"2024-04-16",id:"2024-04-16",level:2},{value:"2024-04-08",id:"2024-04-08",level:2},{value:"2024-04-07",id:"2024-04-07",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"2024-04-30",children:"2024-04-30"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Fixed","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If flow is a single number, if can be parsed to Tank.Hydraulics."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"2024-04-28",children:"2024-04-28"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Changed","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Changed 'is True'/'is False' to '== True'/'== False' to avoid pd.DataFrame problem."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Fixed","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Calculation.Predicted default vaule from np.empty((0, 0)) to pd.DataFrame()."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"2024-04-16",children:"2024-04-16"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Changed","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Target/Tank/Inflow/Flow name cannot be the same."}),"\n",(0,t.jsx)(n.li,{children:"DataSet Connection change the unique index from 'From -> Flow -> Into' to 'From -> Into', so each 'From -> Into' pair is unique."}),"\n",(0,t.jsx)(n.li,{children:"DataSet.Connection 'From' cannot be the same as 'Into' in the same row."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"2024-04-08",children:"2024-04-08"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Added"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Add Chinese support, the Chinese wion't change to ascii."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"2024-04-07",children:"2024-04-07"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Added"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Add Activator sheet in Solution input and Solution._get_Activator() function. The Activator matrix can be used to control the on/off switching of a Tank for a Reaction, e.g. to make sure that the Aeration Reaction only takes place in the Aeration Tank."}),"\n",(0,t.jsx)(n.li,{children:"Point Settling Tank will got a fixed volume fraction, i.e. Outlet / Blanket will always be 8 / 2. Since the BioCalculated of a Point Settling Tank is usually 'False', which means it will not be involved in the reaction. So the concentration in the Point Settling Tank is only determined by the effluent flow. Therefore, the volume is not relevant for the calculation. If detailed calculations are required, other settling tanks should be used, e.g. Double Exponential Settling Tank."}),"\n",(0,t.jsxs)(n.li,{children:["A check for the conflict of derived DataSet.Inflow Component's values in dataset._get_Inflow_MergedTime(): ",(0,t.jsx)(n.code,{children:"If DataSet.Inflow only specifies a Target's values (not a Component's), the Solution.Conversion and Solution.Variable will be used to derive the corresponding Component's values (e.g. in Solution.Conversion we find 'TN=NH4+NO3', the value in Solution.Variable for 'NH4' is 10 and 'NO3' is 1, the 'TN' in DataSet.Inflow is '30', then the derived Inflow 'NH4' is 30*10/(10+1)=27.27 and 'NO3' is 2.73). And you have to make all the DataSet.Inflow values meet the conditions in Solution.Conversion, so these might lead to conflicts. The quickest way to solve this problem is leave the DataSet.Inflow Target's values all empty, or you would have to specify each Component's values in the DataSet.Inflow"})]}),"\n",(0,t.jsx)(n.li,{children:"DataSet.Connection.Flow now supports the number (0~9) and multiplication (*) and division (/)."}),"\n",(0,t.jsx)(n.li,{children:"DataSet.Connection add Section column."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Changed"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Solution._get_Variable(): The order of index in solution_input.Variable does not matter, it will reorder follow thevariable_index_theoretical later."}),"\n",(0,t.jsx)(n.li,{children:"DataSet._get_weight(): The order of index((Target) and columns (Tank) in solution_input.Weight does not matter, it will reorder follow the target_namelist and tank_namelist later."}),"\n",(0,t.jsx)(n.li,{children:"Solution._get_Conversion(): The order of columns (Component) in solution_input.Conversion does not matter, it will reorder follow the component_namelist."}),"\n",(0,t.jsx)(n.li,{children:"DataSet.Inflow can leave a column all empty, or the 1st row cannot be empty."}),"\n",(0,t.jsx)(n.li,{children:"DataSet Tank's name cannot contain '_Outlet'/'_Blanket'."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Improved"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If Solution.Conversion is identity, fortran will skip BioTarget calculation."}),"\n",(0,t.jsx)(n.li,{children:"If BioStoichoimetric_compression is empty, fortran will skip BioStoichoimetric_compression calculation."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Fixed"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["GA Evaluation (",(0,t.jsx)(n.code,{children:"get_Kernel_Evaluation()"}),") will not change the Volume any more (",(0,t.jsx)(n.code,{children:"intent(inout)::Volume -> intent(in)::Volume_in"}),"), so it won't change the PARALLEL ",(0,t.jsx)(n.code,{children:"Trace_BioTarget_Chrom"})," result."]}),"\n",(0,t.jsx)(n.li,{children:"In Calculation.get_fortran_runfile(), '-Ofast' will be used in LHS/GA engine, and '-O3' will be used in SIM/Sens engine to avoid the gfortran isnan always False problem."}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var t=i(6540);const l={},o=t.createContext(l);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);